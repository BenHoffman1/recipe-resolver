<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Modern Industrialization – Recipe Tree Builder (v2)</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<div class="wrap">
  <aside class="left">
    <h1>MI Recipe Tree – v2</h1>
    <div class="card">
      <label for="item">Item</label>
      <div class="ac-wrap">
        <input id="item" type="text" placeholder="singularity" autocomplete="off" />
        <div id="ac" class="ac-list" hidden></div>
      </div>
      <div class="row mt8">
        <div>
          <label for="qty">Quantity</label>
          <input id="qty" type="number" min="1" value="1" />
        </div>
        <div>
          <label for="sort">Sort raw by</label>
          <select id="sort" class="combo">
            <option value="qty">Quantity</option>
            <option value="alpha">A → Z</option>
          </select>
        </div>
      </div>
      <div class="controls">
        <button id="collapseAll" class="btn ghost">Collapse all</button>
      </div>
    </div>

    <div class="card mt16">
      <div class="loader"><span id="loadMsg">Waiting…</span> <div class="bar-outer"><div id="pb" class="bar-inner"></div></div></div>
      <div class="tiny mt8">Index: <span id="statItems">0</span> craftables, <span id="statTags">0</span> tags.</div>
    </div>

    <div class="card mt16">
      <h2 class="m0">Tips</h2>
      <ul class="tiny mt8" style="padding-left:16px; color:var(--muted)">
        <li>Click <b>Pick recipe</b> on any node to choose like JEI.</li>
        <li>Use <b>Expand</b> or <b>Pick recipe</b> next to any <i>input</i> row (e.g. <code>nuke</code>) to open its own picker.</li>
        <li>Toggle <b>Stop here</b> to treat a node as raw.</li>
        <li>We aggregate raw materials & machine runs below the tree.</li>
      </ul>
    </div>
  </aside>

  <main class="right">
    <section class="card">
      <h2>Tree</h2>
      <ul id="tree" class="tree"></ul>
    </section>

    <section class="card mt16">
      <h2>Raw Materials (Aggregated)</h2>
      <table>
        <thead><tr><th>Item</th><th class="nowrap">Total</th></tr></thead>
        <tbody id="rawT"></tbody>
      </table>
      <div class="tiny mt8">Leaves are items where you chose <b>Stop here</b> or that have no recipes.</div>
    </section>
    <section class="card mt16">
      <h2>Machines Summary</h2>
      <table>
        <thead><tr><th>Machine</th><th class="nowrap">Runs</th></tr></thead>
        <tbody id="machT"></tbody>
      </table>
    </section>
  </main>
</div>

<!-- Modal: recipe picker -->
<div id="modal" class="modal" role="dialog" aria-modal="true">
  <div class="panel">
    <div class="bar">
      <strong id="modalTitle">Pick recipe</strong>
      <input id="modalSearch" class="search" placeholder="Filter by machine / ingredient / output" />
      <button id="modalClose" class="btn">Close</button>
    </div>
    <div id="modalGrid" class="grid"></div>
  </div>
</div>

<script>
  // ============================================================
  // v2 – Recipe Tree Builder
  // ============================================================
  let tagsMap = {};           // {"#c:ingots/iron": ["modern_industrialization:iron_ingot", ...]}
  let recipeIndex = {};       // {"modern_industrialization:iron_gear": [Recipe, ...]}
  let allItems = [];          // list of craftable output IDs
  let initialized = false;
  let currentRoot = null;     // root TreeNode

  // UI refs
  const elItem = document.getElementById('item');
  const elAC   = document.getElementById('ac');
  const elQty  = document.getElementById('qty');
  const elTree = document.getElementById('tree');
  const elRawT = document.getElementById('rawT');
  const elMachT= document.getElementById('machT');
  const elLoad = document.getElementById('loadMsg');
  const elPB   = document.getElementById('pb');

  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalSearch = document.getElementById('modalSearch');
  const modalGrid = document.getElementById('modalGrid');
  const modalClose = document.getElementById('modalClose');

  function cleanName(name){
    return String(name)
            .replace(/^fluid:/,'')
            .replace(/^modern_industrialization:/,'')
            .replace(/^minecraft:/,'')
            .replace(/c:/g,'')
            .replace(/^#/, '');
  }

  class Recipe{
    constructor(path, data){
      this.path = path; // recipe file path
      this.data = data; // raw json
      this.outputs = this._getOutputs(); // [[id, count], ...]
    }
    _arr(x){return Array.isArray(x) ? x : (x==null ? [] : [x])}
    _getOutputs(){
      const d=this.data; const outs=[];
      if(d.item_outputs){
        this._arr(d.item_outputs).forEach(o=>{
          if(typeof o==='string') outs.push([o,1]);
          else{ const id=o.item||o.id; if(id) outs.push([id, o.amount||o.count||1]); }
        });
      }
      if(d.fluid_outputs){
        this._arr(d.fluid_outputs).forEach(o=>{ if(o && o.fluid) outs.push([`fluid:${o.fluid}`, o.amount||1]); });
      }
      if(!outs.length && d.result){
        const r=d.result; if(typeof r==='string') outs.push([r,1]); else { const id=r.item||r.id; if(id) outs.push([id, r.count||1]); }
      }
      if(!outs.length && d.results){
        d.results.forEach(o=>{ const id=(typeof o==='string'?o:(o.item||o.id)); if(id) outs.push([id, typeof o==='object' ? (o.count||1) : 1]); });
      }
      return outs;
    }
    getInputs(){
      const d=this.data; const items=[]; const a=x=>Array.isArray(x)?x:(x==null?[]:[x]);
      const add=(e,amt=1)=>{
        if(!e) return;
        if(typeof e==='string') items.push([e, amt]);
        else if(e.item||e.id) items.push([e.item||e.id, amt]);
        else if(e.tag) items.push([`#${e.tag}`, amt]);
      }
      if(d.item_inputs) a(d.item_inputs).forEach(obj=> add(obj, obj.amount||1));
      else if(d.ingredients) d.ingredients.forEach(ing=> add(ing, typeof ing==='object' ? (ing.count||1) : 1));
      else if(d.key && d.pattern){
        const freq={}; d.pattern.join('').split('').forEach(ch=>freq[ch]=(freq[ch]||0)+1);
        Object.entries(d.key).forEach(([ch,ing])=>{ if(freq[ch]) add(ing, freq[ch]); });
      }
      else if(d.ingredient){ add(d.ingredient, 1); }

      if(d.fluid_inputs) a(d.fluid_inputs).forEach(obj=>{ if(obj && obj.fluid) items.push([`fluid:${obj.fluid}`, obj.amount||1]); });
      return items;
    }
  }

  function buildTagMap(tagFiles){
    const map={};
    tagFiles.forEach(({path, values})=>{
      const parts=String(path).replace(/\\/g,'/').split('/');
      const dataIdx=parts.indexOf('data');
      const ns=(dataIdx>=0 && parts.length>dataIdx+1) ? parts[dataIdx+1] : '???';
      const tagIdx = parts.indexOf('items')>=0 ? parts.indexOf('items') : parts.indexOf('item');
      const name = parts.slice(tagIdx+1).join('/').replace(/\.json$/,'');
      const key = `#${ns}:${name}`;
      if(!map[key]) map[key]=[];
      map[key].push(...values);
    });
    Object.keys(map).forEach(k=> map[k]=[...new Set(map[k])]);
    return map;
  }

  function buildRecipeIndex(recipeFiles){
    const idx={};
    for(const {path,data} of recipeFiles){
      const r=new Recipe(path,data);
      r.outputs.forEach(([out])=>{ if(!idx[out]) idx[out]=[]; idx[out].push(r); });
    }
    return idx;
  }

  // Resolve a tag to first concrete entry (BFS through nested tags)
  function concreteFromTag(tag){
    const seen=new Set([tag]); const q=[tag];
    while(q.length){
      const t=q.shift(); const vals=tagsMap[t]||[];
      for(const v of vals){
        if(v.startsWith('#') && !seen.has(v)){ seen.add(v); q.push(v); }
        else if(!v.startsWith('#')){ return v; }
      }
    }
    return null;
  }

  // --- Terminal / normalization helpers ---
  function isTemplate(item){ return String(item).includes('packer_double_ingot_template'); }
  function isTerminalRawItemId(id){
    const nm = String(id).split(':').pop();
    return (nm.includes('dust') && !nm.includes('tiny')) || nm.includes('oxygen');
  }
  function normalizeLeafID(id){
    // Expand tags once (support bare c:* too)
    let sid = String(id);
    if(sid.startsWith('c:')) sid = '#' + sid;
    if(sid.startsWith('#')){ const ci = concreteFromTag(sid); if(ci) id = ci; }
    // If this item has a furnace-like recipe, count dusts instead
    const recsAll = recipeIndex[id] || [];
    const F = new Set(['minecraft:smelting','minecraft:blasting','minecraft:smoking','modern_industrialization:blast_furnace','modern_industrialization:crusher']);
    if(recsAll.some(r=> F.has(r.data.type))){
      const mat = String(id).split(':').pop().replace(/_ore$|_ingot$/,'');
      const dustTag = `#c:dusts/${mat}`;
      const cd = concreteFromTag(dustTag);
      if(cd) return cd;
    }
    return id;
  }

  // ===== Tree model =====
  let nodeAutoId=1;
  class TreeNode{
    constructor(item, qty){
      this.uid = nodeAutoId++;
      this.item = item;           // target output id ("fluid:..." ok)
      this.qty = qty;             // desired amount
      this.recipes = [];          // candidate Recipe[] (that make this.item)
      this.sel = -1;              // selected recipe index in recipes, -1 means none (raw)
      this.runs = 0;              // runs needed for selected recipe
      this.machine = null;        // machine id string
      this.outPerRun = 1;         // how many of target item per run
      this.inputs = [];           // children: [{id, amt, node}] where node is TreeNode
      this.path = null;           // recipe file path
      this.stopHere = false;      // treat as raw
      this.collapsed = false;     // UI toggle
    }
  }

  // scoring heuristic (for default pick)
  function scoreRecipe(r, item){
    const ins = r.getInputs();
    let score = 0;

    // Prefer fewer inputs
    score += ins.length * 2;

    // Strongly prefer dust inputs; penalize complex component inputs
    const compRe = /(rotor|blade|ring|gear|circuit|machine|motor|pump|pipe|cable|battery)/;
    for(const [i] of ins){
      const nm = String(i).split(':').pop();
      if(/dust/.test(nm) && !/tiny/.test(nm)) score -= 20;   // big win
      if(compRe.test(nm)) score += 15;                       // avoid decomposing components
      if(/plate|rod|ring/.test(nm)) score += 3;               // mild penalty vs ingot/ore/dust
      if(/ore|ingot|nugget|block/.test(nm)) score -= 4;       // fairly simple sources
    }

    // If the recipe is explicitly in a components folder, add a penalty
    if(/\/component\//.test(r.path||'')) score += 10;

    // Prefer byproducts (more outputs)
    score -= (r.outputs?.length||0);

    // Prefer higher output per run
    const target = r.outputs?.find(([id])=> id===item);
    const outAmt = target ? (target[1]||1) : 1;
    score -= outAmt * 0.5;

    // Slight bias away from emerald, lead hacks
    if((r.path||'').includes('_lead')) score += 3;

    // Prefer tower slightly when equal
    if(r.data.type?.includes('distillation_tower')) score -= 1;

    return score;
  }

  function getRecipesFor(item){
    let key = item;
    if(typeof key === 'string' && key.startsWith('c:')) key = '#' + key; // treat c:* as a tag
    if(typeof key === 'string' && key.startsWith('#')) key = concreteFromTag(key) || key;
    return recipeIndex[key] ? recipeIndex[key].slice() : [];
  }

  function defaultPick(recipes, item){
    let i = recipes.findIndex(r=> r.data.type?.endsWith(':assembler'));
    if(i>=0) return i;
    // lowest score wins
    let best=-1, bs=Infinity;
    recipes.forEach((r,idx)=>{ const s=scoreRecipe(r,item); if(s<bs){bs=s; best=idx;} });
    return best;
  }

  function buildTree(item, qty, seen=new Set()){
    const node = new TreeNode(item, qty);
    // cycle guard
    const key = `${item}`; if(seen.has(key)){ node.stopHere=true; return node; }
    seen.add(key);

    // default: treat dusts (non-tiny) & oxygen as terminal raw unless user resumes
    if (isTerminalRawItemId(item)) node.stopHere = true;

    node.recipes = getRecipesFor(item);
    if(node.recipes.length){
      node.sel = defaultPick(node.recipes, item);
      applySelection(node);
      // children are built lazily when you expand/pick
    } else {
      node.sel = -1; // raw
    }
    return node;
  }

  function applySelection(node){
    node.inputs.length = 0;
    if(node.sel<0 || !node.recipes[node.sel]){ node.runs=0; node.machine=null; node.outPerRun=1; node.path=null; return; }
    const r=node.recipes[node.sel];
    const out = r.outputs.find(([id])=> id===node.item);
    const outAmt = out ? (out[1]||1) : 1;
    node.outPerRun = outAmt; node.runs = Math.ceil(node.qty / outAmt);
    node.machine = r.data.type?.split(':').pop() || '???';
    node.path = r.path || null;
    // inputs scaled by runs
    r.getInputs().forEach(([ing,amt])=>{
      if(String(ing).includes('packer_double_ingot_template')) return; // skip template
      node.inputs.push({id: ing, amt: (amt||1)*node.runs, node:null});
    });
  }

  // ===== Render =====
  function render(){
    renderTree();
    renderRawSummary();
    renderMachinesSummary();
  }

  function renderTree(){
    elTree.innerHTML='';
    if(!currentRoot) return;
    const ul=document.createElement('ul');
    ul.className='tree';
    ul.appendChild(renderNode(currentRoot));
    elTree.appendChild(ul);
  }

  function makeSlot(text){
    const s=document.createElement('span'); s.className='slot'; s.innerHTML=text; return s;
  }

  function renderNode(node){
    const li=document.createElement('li'); li.className='tree-branch';
    const box=document.createElement('div'); box.className='node'; box.dataset.uid=node.uid;

    // header
    const head=document.createElement('div'); head.className='head';
    const t=document.createElement('div'); t.className='title';
    t.innerHTML = `<span class="pill">${node.qty}×</span> <b>${cleanName(node.item)}</b>`;
    head.appendChild(t);
    const mac=document.createElement('div'); mac.className='machine tiny';
    if(node.sel>=0 && !node.stopHere){ mac.innerHTML = `<span class="pill">${node.machine} × ${node.runs}</span>`; }
    else { mac.innerHTML = `<span class="pill">RAW</span>`; }
    head.appendChild(mac);
    box.appendChild(head);

    // meta line
    const meta=document.createElement('div'); meta.className='meta';
    if(node.path) meta.appendChild(makeSlot(`<span class="muted">file</span> <b>${node.path}</b>`));
    if(node.sel>=0) meta.appendChild(makeSlot(`<span class="muted">per run</span> <b>${node.outPerRun}</b>`));
    box.appendChild(meta);

    // actions
    const actions=document.createElement('div'); actions.className='actions';
    const btnPick=document.createElement('button'); btnPick.className='btn'; btnPick.textContent='Pick recipe';
    btnPick.addEventListener('click', ()=> openRecipePicker(node));
    const btnStop=document.createElement('button'); btnStop.className='btn'; btnStop.textContent = node.stopHere? 'Resume crafting' : 'Stop here';
    btnStop.addEventListener('click', ()=>{ node.stopHere=!node.stopHere; render(); });
    const btnFold=document.createElement('button'); btnFold.className='btn ghost'; btnFold.textContent = node.collapsed? 'Expand' : 'Collapse';
    btnFold.addEventListener('click', ()=>{ node.collapsed=!node.collapsed; renderTree(); });
    actions.appendChild(btnPick); actions.appendChild(btnStop); actions.appendChild(btnFold);
    box.appendChild(actions);

    // children list
    if(!node.stopHere && node.sel>=0 && node.inputs.length){
      const kids=document.createElement('ul'); kids.className='kids'; kids.hidden = node.collapsed;
      for(const inp of node.inputs){
        const kidLi=document.createElement('li'); kidLi.className='tree-branch';

        if(inp.node){
          // already expanded: render full child node
          kidLi.appendChild(renderNode(inp.node));
        } else {
          // collapsed row with quick actions
          const line=document.createElement('div'); line.className='inline';
          line.appendChild(makeSlot(`<b>${inp.amt}</b> × ${cleanName(inp.id)}`));

          const btnExpand=document.createElement('button'); btnExpand.className='btn ghost tiny'; btnExpand.textContent='Expand';
          btnExpand.addEventListener('click', ()=>{
            if(!inp.node){ inp.node = buildTree(inp.id, inp.amt); inp.node.parent = node; }
            kidLi.replaceChildren(renderNode(inp.node));
            render();
          });
          line.appendChild(btnExpand);

          const btnPick=document.createElement('button'); btnPick.className='btn ghost tiny'; btnPick.textContent='Pick recipe';
          btnPick.addEventListener('click', ()=>{
            if(!inp.node){ inp.node = buildTree(inp.id, inp.amt); inp.node.parent = node; }
            openRecipePicker(inp.node);
          });
          line.appendChild(btnPick);

          kidLi.appendChild(line);
        }

        kids.appendChild(kidLi);
      }
      box.appendChild(kids);
    }

    li.appendChild(box);
    return li;
  }

  // ===== Summaries =====
  function aggregateRaw(node, map = {}, visiting = new Set()){
    if(!node) return map;
    if(isTemplate(node.item)) return map;

    const cyc = visiting.has(node.item);
    const terminal = node.stopHere || node.sel < 0 || isTerminalRawItemId(node.item) || !node.inputs.length;
    if(terminal || cyc){
      const id = normalizeLeafID(node.item);
      map[id] = (map[id]||0) + node.qty;
      return map;
    }

    visiting.add(node.item);
    for(const inp of node.inputs){
      if(inp.node){
        aggregateRaw(inp.node, map, visiting);
      } else {
        // virtual traversal: don't instantiate nodes for collapsed branches
        virtualAggregateRaw(inp.id, inp.amt, map, new Set());
      }
    }
    visiting.delete(node.item);
    return map;
  }

  function aggregateMachines(node, map = {}, visiting = new Set()){
    if(!node) return map;
    if(node.sel>=0 && !node.stopHere){
      const machine = node.machine || 'unknown';
      map[machine] = (map[machine]||0) + (node.runs||0);

      if(!visiting.has(node.item)){
        visiting.add(node.item);
        for(const inp of node.inputs){
          if(inp.node){
            aggregateMachines(inp.node, map, visiting);
          } else {
            virtualAggregateMachines(inp.id, inp.amt, map, new Set());
          }
        }
        visiting.delete(node.item);
      }
    }
    return map;
  }

  function renderRawSummary(){
    elRawT.innerHTML=''; if(!currentRoot) return;
    const sort = document.getElementById('sort').value;
    const agg = aggregateRaw(currentRoot, {});
    let entries = Object.entries(agg);
    if(sort==='qty') entries.sort((a,b)=> b[1]-a[1]); else entries.sort((a,b)=> cleanName(a[0]).localeCompare(cleanName(b[0])));
    for(const [id,amt] of entries){
      const tr=document.createElement('tr'); tr.dataset.id=id; tr.style.cursor='pointer';
      const td1=document.createElement('td'); td1.textContent=cleanName(id);
      const td2=document.createElement('td'); td2.textContent=amt;
      tr.appendChild(td1); tr.appendChild(td2); elRawT.appendChild(tr);
      tr.addEventListener('click', ()=> focusRaw(id));
    }
  }

  function renderMachinesSummary(){
    elMachT.innerHTML=''; if(!currentRoot) return;
    const agg = aggregateMachines(currentRoot, {});
    const entries = Object.entries(agg).sort((a,b)=> b[1]-a[1]);
    for(const [m,runs] of entries){
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent=m;
      const td2=document.createElement('td'); td2.textContent=runs;
      tr.appendChild(td1); tr.appendChild(td2); elMachT.appendChild(tr);
    }
  }

  // ===== Modal (JEI-style recipe picker) =====
  let modalTargetNode=null;
  function openRecipePicker(node){
    modalTargetNode = node;
    modalTitle.textContent = `Pick recipe for ${cleanName(node.item)} (${node.qty})`;
    modalSearch.value='';
    fillRecipeGrid(node, '');
    modal.classList.add('on');
  }

  function closeModal(){ modal.classList.remove('on'); modalTargetNode=null; }
  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });
  modalSearch.addEventListener('input', ()=>{ if(modalTargetNode) fillRecipeGrid(modalTargetNode, modalSearch.value.trim().toLowerCase()); });

  function recipeCardHTML(r, item){
    const machine = r.data.type?.split(':').pop() || '???';
    const out = r.outputs.find(([id])=> id===item);
    const count = out ? (out[1]||1) : 1;
    const outs = r.outputs.map(([id,c])=> `<span class="slot"><b>${c||1}</b>× ${cleanName(id)}</span>`).join(' ');
    const ins = r.getInputs().map(([id,c])=> `<span class="slot"><b>${c||1}</b>× ${cleanName(id)}</span>`).join(' ');
    return `
    <div class="recipe-card" data-path="${r.path}">
      <h4>${machine} <span class="muted">(out ${count}/run)</span></h4>
      <div class="io"><div class="tiny muted">Outputs</div>${outs}</div>
      <div class="io mt8"><div class="tiny muted">Inputs</div>${ins}</div>
      <div class="tiny mt8 muted">File: ${r.path}</div>
    </div>`;
  }

  function fillRecipeGrid(node, filter){
    const list = getRecipesFor(node.item);
    const f = (s)=> s.toLowerCase().includes(filter);
    modalGrid.innerHTML = list
            .filter(r=> !filter || f(r.data.type||'') || f(JSON.stringify(r.outputs)) || f(JSON.stringify(r.getInputs())) || f(r.path||''))
            .map(r=> recipeCardHTML(r, node.item))
            .join('');
    // click handling
    modalGrid.querySelectorAll('.recipe-card').forEach((card,idx)=>{
      card.addEventListener('click', ()=>{
        const recipes = getRecipesFor(node.item);
        const chosen = recipes.findIndex(r=> r.path === card.dataset.path) ?? idx;
        node.recipes = recipes; node.sel = chosen; applySelection(node);
        // rebuild children fresh
        node.inputs = node.inputs.map(inp=> { const child = buildTree(inp.id, inp.amt); child.parent = node; return {...inp, node: child}; });
        closeModal();
        render();
      });
    });
  }

  // ===== Autocomplete =====
  let acFocus=-1;
  function showAC(items){
    elAC.innerHTML='';
    if(!items.length){ elAC.hidden=true; return; }
    items.slice(0,24).forEach((val,i)=>{
      const div=document.createElement('div'); div.className='ac-item';
      const disp=cleanName(val);
      const q=elItem.value.trim();
      const re=new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'i');
      div.innerHTML = disp.replace(re, m=>`<b>${m}</b>`);
      div.addEventListener('click',()=>{ elItem.value = disp; elAC.hidden=true; buildTreeFromForm(); });
      elAC.appendChild(div);
    });
    elAC.hidden=false; acFocus=-1;
  }

  elItem.addEventListener('input', ()=>{
    const q=elItem.value.trim().toLowerCase();
    if(!q){ elAC.hidden=true; return; }
    const matches = allItems.filter(id=> cleanName(id).toLowerCase().includes(q));
    showAC(matches);
  });
  // Build/refresh tree when pressing Enter in the Item box
  elItem.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); elAC.hidden=true; buildTreeFromForm(); }});
  // Rebuild the tree when quantity changes
  elQty.addEventListener('change', ()=>{ if(elItem.value.trim()) buildTreeFromForm(); });

  document.addEventListener('keydown', (e)=>{
    if(elAC.hidden) return; const items=[...elAC.querySelectorAll('.ac-item')]; if(!items.length) return;
    if(e.key==='ArrowDown'){ acFocus=(acFocus+1)%items.length; items.forEach(x=>x.classList.remove('active')); items[acFocus].classList.add('active'); e.preventDefault(); }
    if(e.key==='ArrowUp'){ acFocus=(acFocus-1+items.length)%items.length; items.forEach(x=>x.classList.remove('active')); items[acFocus].classList.add('active'); e.preventDefault(); }
    if(e.key==='Enter' && acFocus>-1){ items[acFocus].click(); e.preventDefault(); }
  });


  document.getElementById('collapseAll').addEventListener('click', ()=>{
    if(!currentRoot) return; const walk=(n)=>{ n.collapsed=true; n.inputs.forEach(inp=> inp.node && walk(inp.node)); };
    walk(currentRoot); renderTree();
  });

  document.getElementById('sort').addEventListener('change', ()=>{ renderRawSummary(); });

  function resolveFromCleanName(display){
    return allItems.find(id=> cleanName(id)===display) || display;
  }

  function buildTreeFromForm(){
    const disp=elItem.value.trim(); if(!disp) return;
    const item = resolveFromCleanName(disp);
    const qty = Math.max(1, parseInt(elQty.value,10)||1);
    currentRoot = buildTree(item, qty);
    render();
  }

  // ===== Initialization (load allData.json) =====
  async function init(){
    try{
      elLoad.textContent='Loading allData.json…'; elPB.style.width='5%';
      const {tags, recipes} = await fetch('allData.json').then(r=> r.json());
      elLoad.textContent='Building tag map…'; elPB.style.width='30%';
      tagsMap = buildTagMap(tags); document.getElementById('statTags').textContent = Object.keys(tagsMap).length;

      elLoad.textContent='Indexing recipes…'; elPB.style.width='70%';
      recipeIndex = buildRecipeIndex(recipes);
      allItems = Object.keys(recipeIndex).sort((a,b)=> cleanName(a).localeCompare(cleanName(b)));
      document.getElementById('statItems').textContent = allItems.length;

      elLoad.textContent='Ready'; elPB.style.width='100%';
      initialized=true;
    }catch(err){
      console.error(err);
      elLoad.textContent='Failed to load allData.json. Place it next to this file.';
    }
  }

  init();

  // ===== Virtual traversal (no DOM / no node creation) =====
  const __pickCache = new Map();
  function pickForVirtual(item){
    const key = String(item);
    if(__pickCache.has(key)) return __pickCache.get(key);
    const recs = getRecipesFor(item);
    if(!recs.length){ __pickCache.set(key, null); return null; }
    const idx = defaultPick(recs, item);
    const rec = recs[idx] || null;
    __pickCache.set(key, rec);
    return rec;
  }

  function virtualAggregateRaw(item, qty, map, seen){
    const key = String(item);
    if(seen.has(key)) { // cycle: treat as terminal of this item
      const id = normalizeLeafID(item);
      map[id] = (map[id]||0) + qty;
      return;
    }
    seen.add(key);

    // Treat dusts/oxygen as terminal by default
    if(isTerminalRawItemId(item)){
      const id = normalizeLeafID(item);
      map[id] = (map[id]||0) + qty;
      return;
    }

    const rec = pickForVirtual(item);
    if(!rec){
      const id = normalizeLeafID(item);
      map[id] = (map[id]||0) + qty;
      return;
    }

    const base = item.startsWith('c:') ? (concreteFromTag('#'+item) || item)
            : (item.startsWith('#') ? (concreteFromTag(item)||item) : item);
    const out = rec.outputs.find(([id])=> id===base);
    const outAmt = Math.max(1, out ? (out[1]||1) : 1);
    const runs = Math.ceil(qty / outAmt);

    for(const [ing,amt] of rec.getInputs()){
      if(String(ing).includes('packer_double_ingot_template')) continue;
      virtualAggregateRaw(ing, (amt||1)*runs, map, seen);
    }
  }

  function virtualAggregateMachines(item, qty, map, seen){
    const key = String(item);
    if(seen.has(key)) return; // avoid cycles double-counting
    seen.add(key);

    if(isTerminalRawItemId(item)) return; // terminals have no machines
    const rec = pickForVirtual(item);
    if(!rec) return;

    const base = item.startsWith('c:') ? (concreteFromTag('#'+item) || item)
            : (item.startsWith('#') ? (concreteFromTag(item)||item) : item);
    const out = rec.outputs.find(([id])=> id===base);
    const outAmt = Math.max(1, out ? (out[1]||1) : 1);
    const runs = Math.ceil(qty / outAmt);
    const machine = rec.data.type?.split(':').pop() || 'unknown';
    map[machine] = (map[machine]||0) + runs;

    for(const [ing,amt] of rec.getInputs()){
      if(String(ing).includes('packer_double_ingot_template')) continue;
      virtualAggregateMachines(ing, (amt||1)*runs, map, seen);
    }
  }

  function virtualContains(item, qty, targetId, seen=new Set()){
    const key = String(item);
    if(seen.has(key)) return false;
    seen.add(key);

    const norm = normalizeLeafID(item);
    if(isTerminalRawItemId(item)) return norm === targetId;

    const rec = pickForVirtual(item);
    if(!rec) return norm === targetId;

    const base = item.startsWith('c:') ? (concreteFromTag('#'+item) || item)
            : (item.startsWith('#') ? (concreteFromTag(item)||item) : item);
    const out = rec.outputs.find(([id])=> id===base);
    const outAmt = Math.max(1, out ? (out[1]||1) : 1);
    const runs = Math.ceil(qty / outAmt);

    for(const [ing,amt] of rec.getInputs()){
      if(String(ing).includes('packer_double_ingot_template')) continue;
      if(virtualContains(ing, (amt||1)*runs, targetId, seen)) return true;
    }
    return false;
  }

  // ===== Jump-to-raw: click a row to reveal and highlight in tree =====
  function clearHighlights(){ document.querySelectorAll('.node.highlight').forEach(n=> n.classList.remove('highlight')); }

  function expandPathToRaw(node, targetId){
    if(!node || node.stopHere || node.sel<0) return false;
    let found=false;
    for(const inp of node.inputs){
      if(inp.node){
        if(expandPathToRaw(inp.node, targetId)) { node.collapsed=false; found=true; }
      } else {
        if(virtualContains(inp.id, inp.amt, targetId)){
          inp.node = buildTree(inp.id, inp.amt); inp.node.parent = node;
          // If child is now terminal and matches, mark found, else continue search.
          const term = (inp.node.stopHere || inp.node.sel<0 || !inp.node.inputs.length || isTerminalRawItemId(inp.node.item));
          if(term && normalizeLeafID(inp.node.item)===targetId){ node.collapsed=false; found=true; }
          else if(expandPathToRaw(inp.node, targetId)) { node.collapsed=false; found=true; }
        }
      }
    }
    return found;
  }

  function collectTerminalNodes(node, targetId, out=[]){
    if(!node) return out;
    const terminal = node.stopHere || node.sel<0 || !node.inputs.length || isTerminalRawItemId(node.item);
    if(terminal && normalizeLeafID(node.item)===targetId){ out.push(node); }
    for(const inp of node.inputs){ if(inp.node) collectTerminalNodes(inp.node, targetId, out); }
    return out;
  }

  function focusRaw(rawId){
    if(!currentRoot) return;
    clearHighlights();
    // realize and open only the path(s) that can produce this raw
    expandPathToRaw(currentRoot, rawId);
    // re-render tree (keeps summaries intact)
    renderTree();
    // collect and highlight the matching terminal nodes
    const matches = collectTerminalNodes(currentRoot, rawId, []);
    if(!matches.length) return;
    // choose the SHALLOWEST match (closest to root)
    const depth = (n)=>{ let d=0,p=n.parent; while(p){ d++; p=p.parent; } return d; };
    const best = matches.reduce((a,b)=> depth(a)<=depth(b)?a:b);
    matches.forEach(n=>{
      const el = document.querySelector(`.node[data-uid="${n.uid}"]`);
      if(el) el.classList.add('highlight');
      let p=n.parent; while(p){ p.collapsed=false; p=p.parent; }
    });
    const firstEl = document.querySelector(`.node[data-uid="${best.uid}"]`);
    if(firstEl) firstEl.scrollIntoView({behavior:'smooth', block:'center'});
  }

</script>
</body>
</html>
