<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Modern Industrialization – Recipe Tree Builder (v2)</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#171923; --ink:#e7e9ee; --muted:#a7adbb; --acc:#6ee7b7; --acc2:#60a5fa;
      --danger:#ef4444; --warn:#f59e0b; --ok:#10b981; --chip:#232733;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    a{color:var(--acc2)}

    .wrap{display:grid; grid-template-columns: 340px 1fr; min-height:100vh}
    .left{padding:18px; background:var(--panel); border-right:1px solid #22263a; position:sticky; top:0; align-self:start; min-height:100vh}
    .right{padding:18px;}

    h1{font-size:18px; margin:0 0 12px; letter-spacing:.3px}
    h2{font-size:14px; margin:16px 0 8px; color:var(--muted); font-weight:600; text-transform:uppercase; letter-spacing:.12em}
    .card{background:#131722; border:1px solid #22263a; border-radius:14px; padding:14px; box-shadow:0 1px 0 rgba(255,255,255,.03) inset}
    .row{display:flex; gap:10px;}
    .row>*{flex:1}
    label{display:block; margin:6px 0 6px 2px; color:var(--muted)}
    input[type="text"], input[type="number"], .combo, .search{width:100%; padding:10px 12px; border-radius:10px; border:1px solid #28304a; background:#0f1320; color:var(--ink); outline:none}
    input[type="text"]::placeholder{color:#556}
    .controls{display:flex; gap:10px; align-items:center; margin-top:10px}
    .controls .btn{flex:1}

    .btn{display:inline-flex; align-items:center; justify-content:center; gap:8px; padding:10px 12px; border-radius:10px; border:1px solid #28304a; background:#111525; color:var(--ink); cursor:pointer; user-select:none}
    .btn:hover{border-color:#3a466d; background:#141a31}
    .btn.primary{background:linear-gradient(180deg,#1e293b,#111827); border-color:#2b344f}
    .btn.danger{border-color:#3a2630; background:#221018; color:#fda4af}
    .btn.ghost{background:transparent}

    .tiny{font-size:12px; color:var(--muted)}
    .muted{color:var(--muted)}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; background:var(--chip); color:var(--ink); font-size:12px}

    /* Autocomplete */
    .ac-wrap{position:relative}
    .ac-list{position:absolute; top:100%; left:0; right:0; background:#0f1320; border:1px solid #28304a; border-top:none; max-height:260px; overflow:auto; z-index:20; border-radius:0 0 10px 10px}
    .ac-item{padding:8px 10px; cursor:pointer}
    .ac-item:hover, .ac-item.active{background:#171d35}

    /* Tree */
    .tree{--pad:14px; list-style:none; padding-left:0}
    .tree li{position:relative; margin-left:0; padding-left:0}
    .node{position:relative; margin:10px 0 10px 0; padding:12px 12px 10px 12px; border-radius:12px; background:#101521; border:1px solid #20263b}
    .node .head{display:flex; gap:10px; align-items:baseline; flex-wrap:wrap}
    .node .title{font-weight:600}
    .node .machine{margin-left:auto; opacity:.9}
    .node .meta{display:flex; gap:8px; flex-wrap:wrap; margin-top:6px}
    .node .meta .chip{background:var(--chip); border-radius:999px; padding:2px 8px; font-size:12px}
    .node .slot{display:flex; align-items:center; gap:6px; padding:4px 8px; background:#0c111b; border:1px solid #1b2134; border-radius:10px}
    .node .slot b{font-weight:700}
    .node .actions{display:flex; gap:8px; margin-top:8px; flex-wrap:wrap}

    .kids{list-style:none; padding-left:20px; margin:8px 0 0 14px; border-left:1px dashed #26304f}
    .kids>.tree-branch{position:relative; margin:0 0 8px 0}
    .kids>.tree-branch::before{content:""; position:absolute; left:-14px; top:14px; width:14px; height:1px; background:#26304f}

    .inline{display:inline-flex; gap:8px; align-items:center}

    /* Summary tables */
    table{width:100%; border-collapse:collapse; background:#101521; border:1px solid #20263b; border-radius:12px; overflow:hidden}
    th, td{padding:8px 10px; border-bottom:1px solid #1b2237}
    th{background:#12192a; text-align:left; font-weight:600}
    tbody tr:hover{background:#12182a}

    /* Modal */
    .modal{position:fixed; inset:0; background:rgba(4,6,12,.7); display:none; align-items:center; justify-content:center; padding:24px; z-index:99}
    .modal.on{display:flex}
    .panel{width:min(980px,96vw); max-height:86vh; overflow:auto; background:#0f1320; border:1px solid #2a3351; border-radius:16px; box-shadow:0 30px 60px rgba(0,0,0,.4)}
    .panel .bar{display:flex; align-items:center; gap:12px; padding:12px 14px; position:sticky; top:0; background:#0f1320; border-bottom:1px solid #202744}
    .panel .grid{display:grid; grid-template-columns:repeat(auto-fill, minmax(260px, 1fr)); gap:12px; padding:12px}
    .recipe-card{border:1px solid #273156; border-radius:12px; padding:10px; background:#0c111d; cursor:pointer}
    .recipe-card:hover{border-color:#3a4678; background:#10172a}
    .recipe-card h4{margin:0 0 8px; font-size:13px}
    .io{display:flex; gap:8px; flex-wrap:wrap}
    .io .slot{min-width:fit-content}

    /* Loader */
    .loader{display:flex; align-items:center; gap:10px; color:var(--muted)}
    .bar-outer{height:8px; background:#0c111b; border:1px solid #1b2134; border-radius:8px; overflow:hidden; flex:1}
    .bar-inner{height:100%; width:0%; background:linear-gradient(90deg, var(--acc2), var(--acc)); transition:width .15s ease}

    /* small tweaks */
    .nowrap{white-space:nowrap}
    .m0{margin:0}
    .mt8{margin-top:8px}
    .mt12{margin-top:12px}
    .mt16{margin-top:16px}
    .mt20{margin-top:20px}
  </style>
</head>
<body>
<div class="wrap">
  <aside class="left">
    <h1>MI Recipe Tree – v2</h1>
    <div class="card">
      <label for="item">Item</label>
      <div class="ac-wrap">
        <input id="item" type="text" placeholder="singularity" autocomplete="off" />
        <div id="ac" class="ac-list" hidden></div>
      </div>
      <div class="row mt8">
        <div>
          <label for="qty">Quantity</label>
          <input id="qty" type="number" min="1" value="1" />
        </div>
        <div>
          <label for="sort">Sort raw by</label>
          <select id="sort" class="combo">
            <option value="qty">Quantity</option>
            <option value="alpha">A → Z</option>
          </select>
        </div>
      </div>
      <div class="controls">
        <button id="collapseAll" class="btn ghost">Collapse all</button>
      </div>
      <div class="mt12 tiny">Uses your <code>allData.json</code> (same format as v1). Place it next to this file.</div>
    </div>

    <div class="card mt16">
      <div class="loader"><span id="loadMsg">Waiting…</span> <div class="bar-outer"><div id="pb" class="bar-inner"></div></div></div>
      <div class="tiny mt8">Index: <span id="statItems">0</span> craftables, <span id="statTags">0</span> tags.</div>
    </div>

    <div class="card mt16">
      <h2 class="m0">Tips</h2>
      <ul class="tiny mt8" style="padding-left:16px; color:var(--muted)">
        <li>Click <b>Pick recipe</b> on any node to choose like JEI.</li>
        <li>Use <b>Expand</b> or <b>Pick recipe</b> next to any <i>input</i> row (e.g. <code>nuke</code>) to open its own picker.</li>
        <li>Toggle <b>Stop here</b> to treat a node as raw.</li>
        <li>We aggregate raw materials & machine runs below the tree.</li>
      </ul>
    </div>
  </aside>

  <main class="right">
    <section class="card">
      <h2>Tree</h2>
      <ul id="tree" class="tree"></ul>
    </section>

    <section class="card mt16">
      <h2>Raw Materials (Aggregated)</h2>
      <table>
        <thead><tr><th>Item</th><th class="nowrap">Total</th></tr></thead>
        <tbody id="rawT"></tbody>
      </table>
      <div class="tiny mt8">Leaves are items where you chose <b>Stop here</b> or that have no recipes.</div>
    </section>
    <section class="card mt16">
      <h2>Machines Summary</h2>
      <table>
        <thead><tr><th>Machine</th><th class="nowrap">Runs</th></tr></thead>
        <tbody id="machT"></tbody>
      </table>
    </section>
  </main>
</div>

<!-- Modal: recipe picker -->
<div id="modal" class="modal" role="dialog" aria-modal="true">
  <div class="panel">
    <div class="bar">
      <strong id="modalTitle">Pick recipe</strong>
      <input id="modalSearch" class="search" placeholder="Filter by machine / ingredient / output" />
      <button id="modalClose" class="btn">Close</button>
    </div>
    <div id="modalGrid" class="grid"></div>
  </div>
</div>

<script>
  // ============================================================
  // v2 – Recipe Tree Builder
  // ============================================================
  let tagsMap = {};           // {"#c:ingots/iron": ["modern_industrialization:iron_ingot", ...]}
  let recipeIndex = {};       // {"modern_industrialization:iron_gear": [Recipe, ...]}
  let allItems = [];          // list of craftable output IDs
  let initialized = false;
  let currentRoot = null;     // root TreeNode

  // UI refs
  const elItem = document.getElementById('item');
  const elAC   = document.getElementById('ac');
  const elQty  = document.getElementById('qty');
  const elTree = document.getElementById('tree');
  const elRawT = document.getElementById('rawT');
  const elMachT= document.getElementById('machT');
  const elLoad = document.getElementById('loadMsg');
  const elPB   = document.getElementById('pb');

  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalSearch = document.getElementById('modalSearch');
  const modalGrid = document.getElementById('modalGrid');
  const modalClose = document.getElementById('modalClose');

  function cleanName(name){
    return String(name)
            .replace(/^fluid:/,'')
            .replace(/^modern_industrialization:/,'')
            .replace(/^minecraft:/,'')
            .replace(/c:/g,'');
  }

  class Recipe{
    constructor(path, data){
      this.path = path; // recipe file path
      this.data = data; // raw json
      this.outputs = this._getOutputs(); // [[id, count], ...]
    }
    _arr(x){return Array.isArray(x) ? x : (x==null ? [] : [x])}
    _getOutputs(){
      const d=this.data; const outs=[];
      if(d.item_outputs){
        this._arr(d.item_outputs).forEach(o=>{
          if(typeof o==='string') outs.push([o,1]);
          else{ const id=o.item||o.id; if(id) outs.push([id, o.amount||o.count||1]); }
        });
      }
      if(d.fluid_outputs){
        this._arr(d.fluid_outputs).forEach(o=>{ if(o && o.fluid) outs.push([`fluid:${o.fluid}`, o.amount||1]); });
      }
      if(!outs.length && d.result){
        const r=d.result; if(typeof r==='string') outs.push([r,1]); else { const id=r.item||r.id; if(id) outs.push([id, r.count||1]); }
      }
      if(!outs.length && d.results){
        d.results.forEach(o=>{ const id=(typeof o==='string'?o:(o.item||o.id)); if(id) outs.push([id, typeof o==='object' ? (o.count||1) : 1]); });
      }
      return outs;
    }
    getInputs(){
      const d=this.data; const items=[]; const a=x=>Array.isArray(x)?x:(x==null?[]:[x]);
      const add=(e,amt=1)=>{
        if(!e) return;
        if(typeof e==='string') items.push([e, amt]);
        else if(e.item||e.id) items.push([e.item||e.id, amt]);
        else if(e.tag) items.push([`#${e.tag}`, amt]);
      }
      if(d.item_inputs) a(d.item_inputs).forEach(obj=>add(obj.item||obj.id||obj.tag||obj, obj.amount||1));
      else if(d.ingredients) d.ingredients.forEach(ing=> add(ing, typeof ing==='object' ? (ing.count||1) : 1));
      else if(d.key && d.pattern){
        const freq={}; d.pattern.join('').split('').forEach(ch=>freq[ch]=(freq[ch]||0)+1);
        Object.entries(d.key).forEach(([ch,ing])=>{ if(freq[ch]) add(ing, freq[ch]); });
      }
      else if(d.ingredient){ add(d.ingredient, 1); }

      if(d.fluid_inputs) a(d.fluid_inputs).forEach(obj=>{ if(obj && obj.fluid) items.push([`fluid:${obj.fluid}`, obj.amount||1]); });
      return items;
    }
  }

  function buildTagMap(tagFiles){
    const map={};
    tagFiles.forEach(({path, values})=>{
      const parts=String(path).replace(/\\/g,'/').split('/');
      const dataIdx=parts.indexOf('data');
      const ns=(dataIdx>=0 && parts.length>dataIdx+1) ? parts[dataIdx+1] : '???';
      const tagIdx = parts.indexOf('items')>=0 ? parts.indexOf('items') : parts.indexOf('item');
      const name = parts.slice(tagIdx+1).join('/').replace(/\.json$/,'');
      const key = `#${ns}:${name}`;
      if(!map[key]) map[key]=[];
      map[key].push(...values);
    });
    Object.keys(map).forEach(k=> map[k]=[...new Set(map[k])]);
    return map;
  }

  function buildRecipeIndex(recipeFiles){
    const idx={};
    for(const {path,data} of recipeFiles){
      const r=new Recipe(path,data);
      r.outputs.forEach(([out])=>{ if(!idx[out]) idx[out]=[]; idx[out].push(r); });
    }
    return idx;
  }

  // Resolve a tag to first concrete entry (BFS through nested tags)
  function concreteFromTag(tag){
    const seen=new Set([tag]); const q=[tag];
    while(q.length){
      const t=q.shift(); const vals=tagsMap[t]||[];
      for(const v of vals){
        if(v.startsWith('#') && !seen.has(v)){ seen.add(v); q.push(v); }
        else if(!v.startsWith('#')){ return v; }
      }
    }
    return null;
  }

  // --- Terminal / normalization helpers ---
  function isTemplate(item){ return String(item).includes('packer_double_ingot_template'); }
  function isTerminalRawItemId(id){
    const nm = String(id).split(':').pop();
    return (nm.includes('dust') && !nm.includes('tiny')) || nm.includes('oxygen');
  }
  function normalizeLeafID(id){
    // Expand tags once
    if(String(id).startsWith('#')){ const ci = concreteFromTag(id); if(ci) id = ci; }
    // If this item has a furnace-like recipe, count dusts instead
    const recsAll = recipeIndex[id] || [];
    const F = new Set(['minecraft:smelting','minecraft:blasting','minecraft:smoking','modern_industrialization:blast_furnace','modern_industrialization:crusher']);
    if(recsAll.some(r=> F.has(r.data.type))){
      const mat = String(id).split(':').pop().replace(/_ore$|_ingot$/,'');
      const dustTag = `#c:dusts/${mat}`;
      const cd = concreteFromTag(dustTag);
      if(cd) return cd;
    }
    return id;
  }

  // ===== Tree model =====
  let nodeAutoId=1;
  class TreeNode{
    constructor(item, qty){
      this.uid = nodeAutoId++;
      this.item = item;           // target output id ("fluid:..." ok)
      this.qty = qty;             // desired amount
      this.recipes = [];          // candidate Recipe[] (that make this.item)
      this.sel = -1;              // selected recipe index in recipes, -1 means none (raw)
      this.runs = 0;              // runs needed for selected recipe
      this.machine = null;        // machine id string
      this.outPerRun = 1;         // how many of target item per run
      this.inputs = [];           // children: [{id, amt, node}] where node is TreeNode
      this.path = null;           // recipe file path
      this.stopHere = false;      // treat as raw
      this.collapsed = false;     // UI toggle
    }
  }

  // scoring heuristic (for default pick)
  function scoreRecipe(r, item){
    const ins = r.getInputs();
    let score = ins.length;
    const same = ins.some(([i])=> i===item || i===`#${item}`);
    const compress = ins.some(([i]) => i.includes('_block')||i.includes(':block'));
    const dustBonus= ins.some(([i]) => i.includes('dust'));
    const oreBonus = ins.some(([i]) => i.includes('ore'));
    if(same) score+=8; if(compress) score+=4; if(dustBonus) score-=2; if(oreBonus) score-=1;
    if(ins.some(([id])=> id.includes('emerald'))) score+=50;
    score -= r.outputs.length; // prefer byproducts
    const itemAmt = ins.reduce((s,[,a])=>s+(typeof a==='number'?a:1),0);
    const outAmt = r.outputs.reduce((s,[,c])=>s+(typeof c==='number'?c:1),0);
    score += itemAmt*0.1; score -= outAmt*0.01;
    if(r.path.includes('_lead')) score += 3;
    if(r.data.type?.includes('distillation_tower')) score -= 1;
    return score;
  }

  function getRecipesFor(item){
    // allow tag inputs by concretizing once for display
    const key = item.startsWith('#') ? (concreteFromTag(item) || item) : item;
    return recipeIndex[key] ? recipeIndex[key].slice() : [];
  }

  function defaultPick(recipes, item){
    let i = recipes.findIndex(r=> r.data.type?.endsWith(':assembler'));
    if(i>=0) return i;
    // lowest score wins
    let best=-1, bs=Infinity;
    recipes.forEach((r,idx)=>{ const s=scoreRecipe(r,item); if(s<bs){bs=s; best=idx;} });
    return best;
  }

  function buildTree(item, qty, seen=new Set()){
    const node = new TreeNode(item, qty);
    // cycle guard
    const key = `${item}`; if(seen.has(key)){ node.stopHere=true; return node; }
    seen.add(key);

    node.recipes = getRecipesFor(item);
    if(node.recipes.length){
      node.sel = defaultPick(node.recipes, item);
      applySelection(node);
      // children are built lazily when you expand/pick
    } else {
      node.sel = -1; // raw
    }
    return node;
  }

  function applySelection(node){
    node.inputs.length = 0;
    if(node.sel<0 || !node.recipes[node.sel]){ node.runs=0; node.machine=null; node.outPerRun=1; node.path=null; return; }
    const r=node.recipes[node.sel];
    const out = r.outputs.find(([id])=> id===node.item);
    const outAmt = out ? (out[1]||1) : 1;
    node.outPerRun = outAmt; node.runs = Math.ceil(node.qty / outAmt);
    node.machine = r.data.type?.split(':').pop() || '???';
    node.path = r.path || null;
    // inputs scaled by runs
    r.getInputs().forEach(([ing,amt])=>{
      if(String(ing).includes('packer_double_ingot_template')) return; // skip template
      node.inputs.push({id: ing, amt: (amt||1)*node.runs, node:null});
    });
  }

  // ===== Render =====
  function render(){
    renderTree();
    renderRawSummary();
    renderMachinesSummary();
  }

  function renderTree(){
    elTree.innerHTML='';
    if(!currentRoot) return;
    const ul=document.createElement('ul');
    ul.className='tree';
    ul.appendChild(renderNode(currentRoot));
    elTree.appendChild(ul);
  }

  function makeSlot(text){
    const s=document.createElement('span'); s.className='slot'; s.innerHTML=text; return s;
  }

  function renderNode(node){
    const li=document.createElement('li'); li.className='tree-branch';
    const box=document.createElement('div'); box.className='node'; box.dataset.uid=node.uid;

    // header
    const head=document.createElement('div'); head.className='head';
    const t=document.createElement('div'); t.className='title';
    t.innerHTML = `<span class="pill">${node.qty}×</span> <b>${cleanName(node.item)}</b>`;
    head.appendChild(t);
    const mac=document.createElement('div'); mac.className='machine tiny';
    if(node.sel>=0 && !node.stopHere){ mac.innerHTML = `<span class="pill">${node.machine} × ${node.runs}</span>`; }
    else { mac.innerHTML = `<span class="pill">RAW</span>`; }
    head.appendChild(mac);
    box.appendChild(head);

    // meta line
    const meta=document.createElement('div'); meta.className='meta';
    if(node.path) meta.appendChild(makeSlot(`<span class="muted">file</span> <b>${node.path}</b>`));
    if(node.sel>=0) meta.appendChild(makeSlot(`<span class="muted">per run</span> <b>${node.outPerRun}</b>`));
    box.appendChild(meta);

    // actions
    const actions=document.createElement('div'); actions.className='actions';
    const btnPick=document.createElement('button'); btnPick.className='btn'; btnPick.textContent='Pick recipe';
    btnPick.addEventListener('click', ()=> openRecipePicker(node));
    const btnStop=document.createElement('button'); btnStop.className='btn'; btnStop.textContent = node.stopHere? 'Resume crafting' : 'Stop here';
    btnStop.addEventListener('click', ()=>{ node.stopHere=!node.stopHere; render(); });
    const btnFold=document.createElement('button'); btnFold.className='btn ghost'; btnFold.textContent = node.collapsed? 'Expand' : 'Collapse';
    btnFold.addEventListener('click', ()=>{ node.collapsed=!node.collapsed; renderTree(); });
    actions.appendChild(btnPick); actions.appendChild(btnStop); actions.appendChild(btnFold);
    box.appendChild(actions);

    // children list
    if(!node.stopHere && node.sel>=0 && node.inputs.length){
      const kids=document.createElement('ul'); kids.className='kids'; kids.hidden = node.collapsed;
      for(const inp of node.inputs){
        const kidLi=document.createElement('li'); kidLi.className='tree-branch';

        if(inp.node){
          // already expanded: render full child node
          kidLi.appendChild(renderNode(inp.node));
        } else {
          // collapsed row with quick actions
          const line=document.createElement('div'); line.className='inline';
          line.appendChild(makeSlot(`<b>${inp.amt}</b> × ${cleanName(inp.id)}`));

          const btnExpand=document.createElement('button'); btnExpand.className='btn ghost tiny'; btnExpand.textContent='Expand';
          btnExpand.addEventListener('click', ()=>{
            if(!inp.node) inp.node = buildTree(inp.id, inp.amt);
            kidLi.replaceChildren(renderNode(inp.node));
            render();
          });
          line.appendChild(btnExpand);

          const btnPick=document.createElement('button'); btnPick.className='btn ghost tiny'; btnPick.textContent='Pick recipe';
          btnPick.addEventListener('click', ()=>{
            if(!inp.node) inp.node = buildTree(inp.id, inp.amt);
            openRecipePicker(inp.node);
          });
          line.appendChild(btnPick);

          kidLi.appendChild(line);
        }

        kids.appendChild(kidLi);
      }
      box.appendChild(kids);
    }

    li.appendChild(box);
    return li;
  }

  // ===== Summaries =====
  function aggregateRaw(node, map = {}, visiting = new Set()){
    if(!node) return map;
    if(isTemplate(node.item)) return map;

    // if this node is terminal or we've hit a cycle, treat as raw
    const cyc = visiting.has(node.item);
    const terminal = node.stopHere || node.sel < 0 || isTerminalRawItemId(node.item) || !node.inputs.length;
    if(terminal || cyc){
      const id = normalizeLeafID(node.item);
      map[id] = (map[id]||0) + node.qty;
      return map;
    }

    visiting.add(node.item);
    for(const inp of node.inputs){
      const child = inp.node || buildTree(inp.id, inp.amt);
      aggregateRaw(child, map, visiting);
    }
    visiting.delete(node.item);
    return map;
  }

  function aggregateMachines(node, map = {}, visiting = new Set()){
    if(!node) return map;
    if(node.sel>=0 && !node.stopHere){
      const machine = node.machine || 'unknown';
      map[machine] = (map[machine]||0) + (node.runs||0);

      if(!visiting.has(node.item)){
        visiting.add(node.item);
        for(const inp of node.inputs){
          const child = inp.node || buildTree(inp.id, inp.amt);
          aggregateMachines(child, map, visiting);
        }
        visiting.delete(node.item);
      }
    }
    return map;
  }

  function renderRawSummary(){
    elRawT.innerHTML=''; if(!currentRoot) return;
    const sort = document.getElementById('sort').value;
    const agg = aggregateRaw(currentRoot, {});
    let entries = Object.entries(agg);
    if(sort==='qty') entries.sort((a,b)=> b[1]-a[1]); else entries.sort((a,b)=> cleanName(a[0]).localeCompare(cleanName(b[0])));
    for(const [id,amt] of entries){
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent=cleanName(id);
      const td2=document.createElement('td'); td2.textContent=amt;
      tr.appendChild(td1); tr.appendChild(td2); elRawT.appendChild(tr);
    }
  }

  function renderMachinesSummary(){
    elMachT.innerHTML=''; if(!currentRoot) return;
    const agg = aggregateMachines(currentRoot, {});
    const entries = Object.entries(agg).sort((a,b)=> b[1]-a[1]);
    for(const [m,runs] of entries){
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent=m;
      const td2=document.createElement('td'); td2.textContent=runs;
      tr.appendChild(td1); tr.appendChild(td2); elMachT.appendChild(tr);
    }
  }

  // ===== Modal (JEI-style recipe picker) =====
  let modalTargetNode=null;
  function openRecipePicker(node){
    modalTargetNode = node;
    modalTitle.textContent = `Pick recipe for ${cleanName(node.item)} (${node.qty})`;
    modalSearch.value='';
    fillRecipeGrid(node, '');
    modal.classList.add('on');
  }

  function closeModal(){ modal.classList.remove('on'); modalTargetNode=null; }
  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });
  modalSearch.addEventListener('input', ()=>{ if(modalTargetNode) fillRecipeGrid(modalTargetNode, modalSearch.value.trim().toLowerCase()); });

  function recipeCardHTML(r, item){
    const machine = r.data.type?.split(':').pop() || '???';
    const out = r.outputs.find(([id])=> id===item);
    const count = out ? (out[1]||1) : 1;
    const outs = r.outputs.map(([id,c])=> `<span class="slot"><b>${c||1}</b>× ${cleanName(id)}</span>`).join(' ');
    const ins = r.getInputs().map(([id,c])=> `<span class="slot"><b>${c||1}</b>× ${cleanName(id)}</span>`).join(' ');
    return `
    <div class="recipe-card" data-path="${r.path}">
      <h4>${machine} <span class="muted">(out ${count}/run)</span></h4>
      <div class="io"><div class="tiny muted">Outputs</div>${outs}</div>
      <div class="io mt8"><div class="tiny muted">Inputs</div>${ins}</div>
      <div class="tiny mt8 muted">File: ${r.path}</div>
    </div>`;
  }

  function fillRecipeGrid(node, filter){
    const list = getRecipesFor(node.item);
    const f = (s)=> s.toLowerCase().includes(filter);
    modalGrid.innerHTML = list
            .filter(r=> !filter || f(r.data.type||'') || f(JSON.stringify(r.outputs)) || f(JSON.stringify(r.getInputs())) || f(r.path||''))
            .map(r=> recipeCardHTML(r, node.item))
            .join('');
    // click handling
    modalGrid.querySelectorAll('.recipe-card').forEach((card,idx)=>{
      card.addEventListener('click', ()=>{
        const recipes = getRecipesFor(node.item);
        const chosen = recipes.findIndex(r=> r.path === card.dataset.path) ?? idx;
        node.recipes = recipes; node.sel = chosen; applySelection(node);
        // rebuild children fresh
        node.inputs = node.inputs.map(inp=> ({...inp, node: buildTree(inp.id, inp.amt)}));
        closeModal();
        render();
      });
    });
  }

  // ===== Autocomplete =====
  let acFocus=-1;
  function showAC(items){
    elAC.innerHTML='';
    if(!items.length){ elAC.hidden=true; return; }
    items.slice(0,24).forEach((val,i)=>{
      const div=document.createElement('div'); div.className='ac-item';
      const disp=cleanName(val);
      const q=elItem.value.trim();
      const re=new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'i');
      div.innerHTML = disp.replace(re, m=>`<b>${m}</b>`);
      div.addEventListener('click',()=>{ elItem.value = disp; elAC.hidden=true; buildTreeFromForm(); });
      elAC.appendChild(div);
    });
    elAC.hidden=false; acFocus=-1;
  }

  elItem.addEventListener('input', ()=>{
    const q=elItem.value.trim().toLowerCase();
    if(!q){ elAC.hidden=true; return; }
    const matches = allItems.filter(id=> cleanName(id).toLowerCase().includes(q));
    showAC(matches);
  });
  // Build/refresh tree when pressing Enter in the Item box
  elItem.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); elAC.hidden=true; buildTreeFromForm(); }});
  // Rebuild the tree when quantity changes
  elQty.addEventListener('change', ()=>{ if(elItem.value.trim()) buildTreeFromForm(); });

  document.addEventListener('keydown', (e)=>{
    if(elAC.hidden) return; const items=[...elAC.querySelectorAll('.ac-item')]; if(!items.length) return;
    if(e.key==='ArrowDown'){ acFocus=(acFocus+1)%items.length; items.forEach(x=>x.classList.remove('active')); items[acFocus].classList.add('active'); e.preventDefault(); }
    if(e.key==='ArrowUp'){ acFocus=(acFocus-1+items.length)%items.length; items.forEach(x=>x.classList.remove('active')); items[acFocus].classList.add('active'); e.preventDefault(); }
    if(e.key==='Enter' && acFocus>-1){ items[acFocus].click(); e.preventDefault(); }
  });


  document.getElementById('collapseAll').addEventListener('click', ()=>{
    if(!currentRoot) return; const walk=(n)=>{ n.collapsed=true; n.inputs.forEach(inp=> inp.node && walk(inp.node)); };
    walk(currentRoot); renderTree();
  });

  document.getElementById('sort').addEventListener('change', ()=>{ renderRawSummary(); });

  function resolveFromCleanName(display){
    return allItems.find(id=> cleanName(id)===display) || display;
  }

  function buildTreeFromForm(){
    const disp=elItem.value.trim(); if(!disp) return;
    const item = resolveFromCleanName(disp);
    const qty = Math.max(1, parseInt(elQty.value,10)||1);
    currentRoot = buildTree(item, qty);
    render();
  }

  // ===== Initialization (load allData.json) =====
  async function init(){
    try{
      elLoad.textContent='Loading allData.json…'; elPB.style.width='5%';
      const {tags, recipes} = await fetch('allData.json').then(r=> r.json());
      elLoad.textContent='Building tag map…'; elPB.style.width='30%';
      tagsMap = buildTagMap(tags); document.getElementById('statTags').textContent = Object.keys(tagsMap).length;

      elLoad.textContent='Indexing recipes…'; elPB.style.width='70%';
      recipeIndex = buildRecipeIndex(recipes);
      allItems = Object.keys(recipeIndex).sort((a,b)=> cleanName(a).localeCompare(cleanName(b)));
      document.getElementById('statItems').textContent = allItems.length;

      elLoad.textContent='Ready'; elPB.style.width='100%';
      initialized=true;
    }catch(err){
      console.error(err);
      elLoad.textContent='Failed to load allData.json. Place it next to this file.';
    }
  }

  init();
</script>
</body>
</html>
